/* soapStub.h
   Generated by gSOAP 2.8.16 from ServerAPI.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"http://impl.service.wfe.runa.ru/"
#define SOAP_NAMESPACE_OF_ns2	"http://stub.service.wfe.runa.ru/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20816
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__nodeType
#define SOAP_TYPE_ns1__nodeType (111)
/* ns1:nodeType */
enum ns1__nodeType { ns1__nodeType__START_USCOREEVENT = 0, ns1__nodeType__ACTION_USCORENODE = 1, ns1__nodeType__END_USCOREPROCESS = 2, ns1__nodeType__WAIT_USCORESTATE = 3, ns1__nodeType__TASK_USCORESTATE = 4, ns1__nodeType__FORK = 5, ns1__nodeType__JOIN = 6, ns1__nodeType__DECISION = 7, ns1__nodeType__SUBPROCESS = 8, ns1__nodeType__MULTI_USCORESUBPROCESS = 9, ns1__nodeType__SEND_USCOREMESSAGE = 10, ns1__nodeType__RECEIVE_USCOREMESSAGE = 11, ns1__nodeType__END_USCORETOKEN = 12, ns1__nodeType__MULTI_USCORETASK_USCORESTATE = 13, ns1__nodeType__MERGE = 14, ns1__nodeType__EXCLUSIVE_USCOREGATEWAY = 15, ns1__nodeType__PARALLEL_USCOREGATEWAY = 16 };
#endif

#ifndef SOAP_TYPE_ns1__classPresentationType
#define SOAP_TYPE_ns1__classPresentationType (113)
/* ns1:classPresentationType */
enum ns1__classPresentationType { ns1__classPresentationType__NONE = 0, ns1__classPresentationType__SYSTEM_USCORELOG = 1, ns1__classPresentationType__EXECUTOR = 2, ns1__classPresentationType__ACTOR = 3, ns1__classPresentationType__GROUP = 4, ns1__classPresentationType__RELATION = 5, ns1__classPresentationType__RELATIONPAIR = 6, ns1__classPresentationType__DEFINITION = 7, ns1__classPresentationType__PROCESS = 8, ns1__classPresentationType__TASK = 9 };
#endif

#ifndef SOAP_TYPE_ns1__severity
#define SOAP_TYPE_ns1__severity (115)
/* ns1:severity */
enum ns1__severity { ns1__severity__DEBUG = 0, ns1__severity__ERROR = 1, ns1__severity__INFO = 2 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (13)
/* Primitive xsd:base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_xsd__base64Binary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (14)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (16)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (18)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
/* Primitive xsd:long schema type: */
class SOAP_CMAC xsd__long : public xsd__anyType
{
public:
	LONG64 __item;
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_xsd__long */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__long() { xsd__long::soap_default(NULL); }
	virtual ~xsd__long() { }
};
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (21)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	wchar_t *__item;
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_ns1__nodeType_
#define SOAP_TYPE_ns1__nodeType_ (112)
/* Primitive ns1:nodeType schema type: */
class SOAP_CMAC ns1__nodeType_ : public xsd__anyType
{
public:
	enum ns1__nodeType __item;
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns1__nodeType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__nodeType_() { ns1__nodeType_::soap_default(NULL); }
	virtual ~ns1__nodeType_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__classPresentationType_
#define SOAP_TYPE_ns1__classPresentationType_ (114)
/* Primitive ns1:classPresentationType schema type: */
class SOAP_CMAC ns1__classPresentationType_ : public xsd__anyType
{
public:
	enum ns1__classPresentationType __item;
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_ns1__classPresentationType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__classPresentationType_() { ns1__classPresentationType_::soap_default(NULL); }
	virtual ~ns1__classPresentationType_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__severity_
#define SOAP_TYPE_ns1__severity_ (116)
/* Primitive ns1:severity schema type: */
class SOAP_CMAC ns1__severity_ : public xsd__anyType
{
public:
	enum ns1__severity __item;
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_ns1__severity_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__severity_() { ns1__severity_::soap_default(NULL); }
	virtual ~ns1__severity_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByLoginPassword
#define SOAP_TYPE_ns1__authenticateByLoginPassword (24)
/* ns1:authenticateByLoginPassword */
class SOAP_CMAC ns1__authenticateByLoginPassword : public xsd__anyType
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__authenticateByLoginPassword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByLoginPassword() { ns1__authenticateByLoginPassword::soap_default(NULL); }
	virtual ~ns1__authenticateByLoginPassword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByLoginPasswordResponse
#define SOAP_TYPE_ns1__authenticateByLoginPasswordResponse (25)
/* ns1:authenticateByLoginPasswordResponse */
class SOAP_CMAC ns1__authenticateByLoginPasswordResponse : public xsd__anyType
{
public:
	class ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__authenticateByLoginPasswordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByLoginPasswordResponse() { ns1__authenticateByLoginPasswordResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByLoginPasswordResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__user
#define SOAP_TYPE_ns1__user (26)
/* ns1:user */
class SOAP_CMAC ns1__user : public xsd__anyType
{
public:
	class ns1__actor *actor;	/* optional element of type ns1:actor */
	xsd__base64Binary *securedKey;	/* optional element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__user */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__user() { ns1__user::soap_default(NULL); }
	virtual ~ns1__user() { }
};
#endif

#ifndef SOAP_TYPE_ns1__identifiable
#define SOAP_TYPE_ns1__identifiable (30)
/* Primitive ns1:identifiable schema type: */
class SOAP_CMAC ns1__identifiable : public xsd__anyType
{
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__identifiable */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__identifiable() { ns1__identifiable::soap_default(NULL); }
	virtual ~ns1__identifiable() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipal
#define SOAP_TYPE_ns1__authenticateByCallerPrincipal (31)
/* Primitive ns1:authenticateByCallerPrincipal schema type: */
class SOAP_CMAC ns1__authenticateByCallerPrincipal : public xsd__anyType
{
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__authenticateByCallerPrincipal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByCallerPrincipal() { ns1__authenticateByCallerPrincipal::soap_default(NULL); }
	virtual ~ns1__authenticateByCallerPrincipal() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse (32)
/* ns1:authenticateByCallerPrincipalResponse */
class SOAP_CMAC ns1__authenticateByCallerPrincipalResponse : public xsd__anyType
{
public:
	ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByCallerPrincipalResponse() { ns1__authenticateByCallerPrincipalResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByCallerPrincipalResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByKerberos
#define SOAP_TYPE_ns1__authenticateByKerberos (33)
/* ns1:authenticateByKerberos */
class SOAP_CMAC ns1__authenticateByKerberos : public xsd__anyType
{
public:
	xsd__base64Binary *token;	/* optional element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__authenticateByKerberos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByKerberos() { ns1__authenticateByKerberos::soap_default(NULL); }
	virtual ~ns1__authenticateByKerberos() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByKerberosResponse
#define SOAP_TYPE_ns1__authenticateByKerberosResponse (34)
/* ns1:authenticateByKerberosResponse */
class SOAP_CMAC ns1__authenticateByKerberosResponse : public xsd__anyType
{
public:
	ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__authenticateByKerberosResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByKerberosResponse() { ns1__authenticateByKerberosResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByKerberosResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessHistoryDiagramElements
#define SOAP_TYPE_ns1__getProcessHistoryDiagramElements (35)
/* ns1:getProcessHistoryDiagramElements */
class SOAP_CMAC ns1__getProcessHistoryDiagramElements : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	LONG64 *taskId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__getProcessHistoryDiagramElements */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessHistoryDiagramElements() { ns1__getProcessHistoryDiagramElements::soap_default(NULL); }
	virtual ~ns1__getProcessHistoryDiagramElements() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse
#define SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse (36)
/* ns1:getProcessHistoryDiagramElementsResponse */
class SOAP_CMAC ns1__getProcessHistoryDiagramElementsResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	class ns1__graphElementPresentation **result;	/* optional element of type ns1:graphElementPresentation */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessHistoryDiagramElementsResponse() { ns1__getProcessHistoryDiagramElementsResponse::soap_default(NULL); }
	virtual ~ns1__getProcessHistoryDiagramElementsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__graphElementPresentation
#define SOAP_TYPE_ns1__graphElementPresentation (37)
/* ns1:graphElementPresentation */
class SOAP_CMAC ns1__graphElementPresentation : public xsd__anyType
{
public:
	wchar_t *nodeId;	/* optional element of type xsd:string */
	enum ns1__nodeType *nodeType;	/* optional element of type ns1:nodeType */
	wchar_t *name;	/* optional element of type xsd:string */
	int __sizegraphConstraints;	/* sequence of elements <graphConstraints> */
	int *graphConstraints;	/* optional element of type xsd:int */
	xsd__anyType *data;	/* optional element of type xsd:anyType */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__graphElementPresentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__graphElementPresentation() { ns1__graphElementPresentation::soap_default(NULL); }
	virtual ~ns1__graphElementPresentation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTask
#define SOAP_TYPE_ns1__getTask (38)
/* ns1:getTask */
class SOAP_CMAC ns1__getTask : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__getTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTask() { ns1__getTask::soap_default(NULL); }
	virtual ~ns1__getTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTaskResponse
#define SOAP_TYPE_ns1__getTaskResponse (39)
/* ns1:getTaskResponse */
class SOAP_CMAC ns1__getTaskResponse : public xsd__anyType
{
public:
	class ns1__wfTask *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__getTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTaskResponse() { ns1__getTaskResponse::soap_default(NULL); }
	virtual ~ns1__getTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wfTask
#define SOAP_TYPE_ns1__wfTask (40)
/* ns1:wfTask */
class SOAP_CMAC ns1__wfTask : public xsd__anyType
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *nodeId;	/* optional element of type xsd:string */
	wchar_t *description;	/* optional element of type xsd:string */
	wchar_t *swimlaneName;	/* optional element of type xsd:string */
	class ns1__wfExecutor *owner;	/* optional element of type ns1:wfExecutor */
	ns1__actor *targetActor;	/* optional element of type ns1:actor */
	LONG64 *definitionId;	/* optional element of type xsd:long */
	wchar_t *definitionName;	/* optional element of type xsd:string */
	LONG64 *processId;	/* optional element of type xsd:long */
	time_t *creationDate;	/* optional element of type xsd:dateTime */
	time_t *deadlineDate;	/* optional element of type xsd:dateTime */
	time_t *deadlineWarningDate;	/* optional element of type xsd:dateTime */
	bool escalated;	/* required element of type xsd:boolean */
	bool firstOpen;	/* required element of type xsd:boolean */
	bool acquiredBySubstitution;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__wfTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wfTask() { ns1__wfTask::soap_default(NULL); }
	virtual ~ns1__wfTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcess
#define SOAP_TYPE_ns1__getProcess (42)
/* ns1:getProcess */
class SOAP_CMAC ns1__getProcess : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *id;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__getProcess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcess() { ns1__getProcess::soap_default(NULL); }
	virtual ~ns1__getProcess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessResponse
#define SOAP_TYPE_ns1__getProcessResponse (43)
/* ns1:getProcessResponse */
class SOAP_CMAC ns1__getProcessResponse : public xsd__anyType
{
public:
	class ns1__wfProcess *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:wfProcess */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__getProcessResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessResponse() { ns1__getProcessResponse::soap_default(NULL); }
	virtual ~ns1__getProcessResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getVariable
#define SOAP_TYPE_ns1__getVariable (45)
/* ns1:getVariable */
class SOAP_CMAC ns1__getVariable : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	wchar_t *variableName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__getVariable */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getVariable() { ns1__getVariable::soap_default(NULL); }
	virtual ~ns1__getVariable() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getVariableResponse
#define SOAP_TYPE_ns1__getVariableResponse (46)
/* ns1:getVariableResponse */
class SOAP_CMAC ns1__getVariableResponse : public xsd__anyType
{
public:
	class ns2__wfVariableStub *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:wfVariableStub */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__getVariableResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getVariableResponse() { ns1__getVariableResponse::soap_default(NULL); }
	virtual ~ns1__getVariableResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__variableDefinition_userTypes_entry
#define SOAP_TYPE__ns1__variableDefinition_userTypes_entry (132)
/* ns1:variableDefinition-userTypes-entry */
class SOAP_CMAC _ns1__variableDefinition_userTypes_entry
{
public:
	wchar_t *key;	/* optional element of type xsd:string */
	class ns1__variableUserType *value;	/* optional element of type ns1:variableUserType */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE__ns1__variableDefinition_userTypes_entry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__variableDefinition_userTypes_entry() { _ns1__variableDefinition_userTypes_entry::soap_default(NULL); }
	virtual ~_ns1__variableDefinition_userTypes_entry() { }
};
#endif

#ifndef SOAP_TYPE__ns1__variableDefinition_userTypes
#define SOAP_TYPE__ns1__variableDefinition_userTypes (131)
/* ns1:variableDefinition-userTypes */
class SOAP_CMAC _ns1__variableDefinition_userTypes
{
public:
	int __sizeentry;	/* sequence of elements <entry> */
	_ns1__variableDefinition_userTypes_entry *entry;	/* optional element of type ns1:variableDefinition-userTypes-entry */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE__ns1__variableDefinition_userTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__variableDefinition_userTypes() { _ns1__variableDefinition_userTypes::soap_default(NULL); }
	virtual ~_ns1__variableDefinition_userTypes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__variableDefinition
#define SOAP_TYPE_ns1__variableDefinition (47)
/* ns1:variableDefinition */
class SOAP_CMAC ns1__variableDefinition : public xsd__anyType
{
public:
	bool synthetic;	/* required element of type xsd:boolean */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *format;	/* optional element of type xsd:string */
	bool publicAccess;	/* required element of type xsd:boolean */
	wchar_t *defaultValue;	/* optional element of type xsd:string */
	wchar_t *scriptingName;	/* optional element of type xsd:string */
	wchar_t *formatLabel;	/* optional element of type xsd:string */
	_ns1__variableDefinition_userTypes userTypes;	/* required element of type ns1:variableDefinition-userTypes */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__variableDefinition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__variableDefinition() { ns1__variableDefinition::soap_default(NULL); }
	virtual ~ns1__variableDefinition() { }
};
#endif

#ifndef SOAP_TYPE_ns1__variableUserType
#define SOAP_TYPE_ns1__variableUserType (48)
/* ns1:variableUserType */
class SOAP_CMAC ns1__variableUserType : public xsd__anyType
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	int __sizeattributes;	/* sequence of elements <attributes> */
	ns1__variableDefinition **attributes;	/* optional element of type ns1:variableDefinition */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__variableUserType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__variableUserType() { ns1__variableUserType::soap_default(NULL); }
	virtual ~ns1__variableUserType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessesCount
#define SOAP_TYPE_ns1__getProcessesCount (49)
/* ns1:getProcessesCount */
class SOAP_CMAC ns1__getProcessesCount : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	class ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__getProcessesCount */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessesCount() { ns1__getProcessesCount::soap_default(NULL); }
	virtual ~ns1__getProcessesCount() { }
};
#endif

#ifndef SOAP_TYPE_ns1__batchPresentation
#define SOAP_TYPE_ns1__batchPresentation (50)
/* ns1:batchPresentation */
class SOAP_CMAC ns1__batchPresentation : public xsd__anyType
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *version;	/* optional element of type xsd:long */
	enum ns1__classPresentationType *type;	/* optional element of type ns1:classPresentationType */
	wchar_t *category;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	bool active;	/* required element of type xsd:boolean */
	int rangeSize;	/* required element of type xsd:int */
	int pageNumber;	/* required element of type xsd:int */
	xsd__base64Binary *fieldsData;	/* optional element of type xsd:base64Binary */
	time_t *createDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__batchPresentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__batchPresentation() { ns1__batchPresentation::soap_default(NULL); }
	virtual ~ns1__batchPresentation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessesCountResponse
#define SOAP_TYPE_ns1__getProcessesCountResponse (51)
/* ns1:getProcessesCountResponse */
class SOAP_CMAC ns1__getProcessesCountResponse : public xsd__anyType
{
public:
	int result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__getProcessesCountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessesCountResponse() { ns1__getProcessesCountResponse::soap_default(NULL); }
	virtual ~ns1__getProcessesCountResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessesByFilter
#define SOAP_TYPE_ns1__getProcessesByFilter (52)
/* ns1:getProcessesByFilter */
class SOAP_CMAC ns1__getProcessesByFilter : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	class ns1__processFilter *filter;	/* optional element of type ns1:processFilter */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__getProcessesByFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessesByFilter() { ns1__getProcessesByFilter::soap_default(NULL); }
	virtual ~ns1__getProcessesByFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__processFilter
#define SOAP_TYPE_ns1__processFilter (53)
/* ns1:processFilter */
class SOAP_CMAC ns1__processFilter : public xsd__anyType
{
public:
	wchar_t *definitionName;	/* optional element of type xsd:string */
	LONG64 *definitionVersion;	/* optional element of type xsd:long */
	time_t *endDateFrom;	/* optional element of type xsd:dateTime */
	time_t *endDateTo;	/* optional element of type xsd:dateTime */
	bool *finishedOnly;	/* optional element of type xsd:boolean */
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *idFrom;	/* optional element of type xsd:long */
	LONG64 *idTo;	/* optional element of type xsd:long */
	time_t *startDateFrom;	/* optional element of type xsd:dateTime */
	time_t *startDateTo;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__processFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__processFilter() { ns1__processFilter::soap_default(NULL); }
	virtual ~ns1__processFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessesByFilterResponse
#define SOAP_TYPE_ns1__getProcessesByFilterResponse (54)
/* ns1:getProcessesByFilterResponse */
class SOAP_CMAC ns1__getProcessesByFilterResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfProcess **result;	/* optional element of type ns1:wfProcess */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__getProcessesByFilterResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessesByFilterResponse() { ns1__getProcessesByFilterResponse::soap_default(NULL); }
	virtual ~ns1__getProcessesByFilterResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getParentProcess
#define SOAP_TYPE_ns1__getParentProcess (55)
/* ns1:getParentProcess */
class SOAP_CMAC ns1__getParentProcess : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *id;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__getParentProcess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getParentProcess() { ns1__getParentProcess::soap_default(NULL); }
	virtual ~ns1__getParentProcess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getParentProcessResponse
#define SOAP_TYPE_ns1__getParentProcessResponse (56)
/* ns1:getParentProcessResponse */
class SOAP_CMAC ns1__getParentProcessResponse : public xsd__anyType
{
public:
	ns1__wfProcess *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:wfProcess */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__getParentProcessResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getParentProcessResponse() { ns1__getParentProcessResponse::soap_default(NULL); }
	virtual ~ns1__getParentProcessResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSubprocesses
#define SOAP_TYPE_ns1__getSubprocesses (57)
/* ns1:getSubprocesses */
class SOAP_CMAC ns1__getSubprocesses : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *id;	/* optional element of type xsd:long */
	bool recursive;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__getSubprocesses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSubprocesses() { ns1__getSubprocesses::soap_default(NULL); }
	virtual ~ns1__getSubprocesses() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSubprocessesResponse
#define SOAP_TYPE_ns1__getSubprocessesResponse (58)
/* ns1:getSubprocessesResponse */
class SOAP_CMAC ns1__getSubprocessesResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfProcess **result;	/* optional element of type ns1:wfProcess */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__getSubprocessesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSubprocessesResponse() { ns1__getSubprocessesResponse::soap_default(NULL); }
	virtual ~ns1__getSubprocessesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cancelProcess
#define SOAP_TYPE_ns1__cancelProcess (59)
/* ns1:cancelProcess */
class SOAP_CMAC ns1__cancelProcess : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__cancelProcess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cancelProcess() { ns1__cancelProcess::soap_default(NULL); }
	virtual ~ns1__cancelProcess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cancelProcessResponse
#define SOAP_TYPE_ns1__cancelProcessResponse (60)
/* Primitive ns1:cancelProcessResponse schema type: */
class SOAP_CMAC ns1__cancelProcessResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__cancelProcessResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cancelProcessResponse() { ns1__cancelProcessResponse::soap_default(NULL); }
	virtual ~ns1__cancelProcessResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessTasks
#define SOAP_TYPE_ns1__getProcessTasks (61)
/* ns1:getProcessTasks */
class SOAP_CMAC ns1__getProcessTasks : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__getProcessTasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessTasks() { ns1__getProcessTasks::soap_default(NULL); }
	virtual ~ns1__getProcessTasks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessTasksResponse
#define SOAP_TYPE_ns1__getProcessTasksResponse (62)
/* ns1:getProcessTasksResponse */
class SOAP_CMAC ns1__getProcessTasksResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfTask **result;	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__getProcessTasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessTasksResponse() { ns1__getProcessTasksResponse::soap_default(NULL); }
	virtual ~ns1__getProcessTasksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessDiagram
#define SOAP_TYPE_ns1__getProcessDiagram (63)
/* ns1:getProcessDiagram */
class SOAP_CMAC ns1__getProcessDiagram : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	LONG64 *taskId;	/* optional element of type xsd:long */
	LONG64 *childProcessId;	/* optional element of type xsd:long */
	wchar_t *subprocessId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns1__getProcessDiagram */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessDiagram() { ns1__getProcessDiagram::soap_default(NULL); }
	virtual ~ns1__getProcessDiagram() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessDiagramResponse
#define SOAP_TYPE_ns1__getProcessDiagramResponse (64)
/* ns1:getProcessDiagramResponse */
class SOAP_CMAC ns1__getProcessDiagramResponse : public xsd__anyType
{
public:
	xsd__base64Binary *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__getProcessDiagramResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessDiagramResponse() { ns1__getProcessDiagramResponse::soap_default(NULL); }
	virtual ~ns1__getProcessDiagramResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessHistoryDiagram
#define SOAP_TYPE_ns1__getProcessHistoryDiagram (65)
/* ns1:getProcessHistoryDiagram */
class SOAP_CMAC ns1__getProcessHistoryDiagram : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	LONG64 *taskId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__getProcessHistoryDiagram */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessHistoryDiagram() { ns1__getProcessHistoryDiagram::soap_default(NULL); }
	virtual ~ns1__getProcessHistoryDiagram() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessHistoryDiagramResponse
#define SOAP_TYPE_ns1__getProcessHistoryDiagramResponse (66)
/* ns1:getProcessHistoryDiagramResponse */
class SOAP_CMAC ns1__getProcessHistoryDiagramResponse : public xsd__anyType
{
public:
	xsd__base64Binary *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__getProcessHistoryDiagramResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessHistoryDiagramResponse() { ns1__getProcessHistoryDiagramResponse::soap_default(NULL); }
	virtual ~ns1__getProcessHistoryDiagramResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessDiagramElements
#define SOAP_TYPE_ns1__getProcessDiagramElements (67)
/* ns1:getProcessDiagramElements */
class SOAP_CMAC ns1__getProcessDiagramElements : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	wchar_t *subprocessId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns1__getProcessDiagramElements */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessDiagramElements() { ns1__getProcessDiagramElements::soap_default(NULL); }
	virtual ~ns1__getProcessDiagramElements() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessDiagramElementsResponse
#define SOAP_TYPE_ns1__getProcessDiagramElementsResponse (68)
/* ns1:getProcessDiagramElementsResponse */
class SOAP_CMAC ns1__getProcessDiagramElementsResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__graphElementPresentation **result;	/* optional element of type ns1:graphElementPresentation */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__getProcessDiagramElementsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessDiagramElementsResponse() { ns1__getProcessDiagramElementsResponse::soap_default(NULL); }
	virtual ~ns1__getProcessDiagramElementsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignSwimlane
#define SOAP_TYPE_ns1__assignSwimlane (69)
/* ns1:assignSwimlane */
class SOAP_CMAC ns1__assignSwimlane : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	wchar_t *swimlaneName;	/* optional element of type xsd:string */
	ns1__wfExecutor *executor;	/* optional element of type ns1:wfExecutor */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns1__assignSwimlane */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignSwimlane() { ns1__assignSwimlane::soap_default(NULL); }
	virtual ~ns1__assignSwimlane() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignSwimlaneResponse
#define SOAP_TYPE_ns1__assignSwimlaneResponse (70)
/* Primitive ns1:assignSwimlaneResponse schema type: */
class SOAP_CMAC ns1__assignSwimlaneResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__assignSwimlaneResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignSwimlaneResponse() { ns1__assignSwimlaneResponse::soap_default(NULL); }
	virtual ~ns1__assignSwimlaneResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessLogs
#define SOAP_TYPE_ns1__getProcessLogs (71)
/* ns1:getProcessLogs */
class SOAP_CMAC ns1__getProcessLogs : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	class ns1__processLogFilter *filter;	/* optional element of type ns1:processLogFilter */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__getProcessLogs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessLogs() { ns1__getProcessLogs::soap_default(NULL); }
	virtual ~ns1__getProcessLogs() { }
};
#endif

#ifndef SOAP_TYPE_ns1__processLogFilter
#define SOAP_TYPE_ns1__processLogFilter (72)
/* ns1:processLogFilter */
class SOAP_CMAC ns1__processLogFilter : public xsd__anyType
{
public:
	bool includeSubprocessLogs;	/* required element of type xsd:boolean */
	LONG64 *processId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__processLogFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__processLogFilter() { ns1__processLogFilter::soap_default(NULL); }
	virtual ~ns1__processLogFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessLogsResponse
#define SOAP_TYPE_ns1__getProcessLogsResponse (73)
/* ns1:getProcessLogsResponse */
class SOAP_CMAC ns1__getProcessLogsResponse : public xsd__anyType
{
public:
	class ns1__processLogs *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:processLogs */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns1__getProcessLogsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessLogsResponse() { ns1__getProcessLogsResponse::soap_default(NULL); }
	virtual ~ns1__getProcessLogsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__processLogs
#define SOAP_TYPE_ns1__processLogs (74)
/* ns1:processLogs */
class SOAP_CMAC ns1__processLogs : public xsd__anyType
{
public:
	int __sizelogs;	/* sequence of elements <logs> */
	class ns1__processLog **logs;	/* optional element of type ns1:processLog */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__processLogs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__processLogs() { ns1__processLogs::soap_default(NULL); }
	virtual ~ns1__processLogs() { }
};
#endif

#ifndef SOAP_TYPE_ns1__processLog
#define SOAP_TYPE_ns1__processLog (75)
/* ns1:processLog */
class SOAP_CMAC ns1__processLog : public xsd__anyType
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *processId;	/* optional element of type xsd:long */
	LONG64 *tokenId;	/* optional element of type xsd:long */
	time_t *createDate;	/* optional element of type xsd:dateTime */
	enum ns1__severity *severity;	/* optional element of type ns1:severity */
	xsd__base64Binary *bytes;	/* optional element of type xsd:base64Binary */
	wchar_t *nodeId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns1__processLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__processLog() { ns1__processLog::soap_default(NULL); }
	virtual ~ns1__processLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessLogValue
#define SOAP_TYPE_ns1__getProcessLogValue (76)
/* ns1:getProcessLogValue */
class SOAP_CMAC ns1__getProcessLogValue : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *logId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns1__getProcessLogValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessLogValue() { ns1__getProcessLogValue::soap_default(NULL); }
	virtual ~ns1__getProcessLogValue() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessLogValueResponse
#define SOAP_TYPE_ns1__getProcessLogValueResponse (77)
/* ns1:getProcessLogValueResponse */
class SOAP_CMAC ns1__getProcessLogValueResponse : public xsd__anyType
{
public:
	xsd__anyType *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns1__getProcessLogValueResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessLogValueResponse() { ns1__getProcessLogValueResponse::soap_default(NULL); }
	virtual ~ns1__getProcessLogValueResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__markTaskOpened
#define SOAP_TYPE_ns1__markTaskOpened (78)
/* ns1:markTaskOpened */
class SOAP_CMAC ns1__markTaskOpened : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__markTaskOpened */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__markTaskOpened() { ns1__markTaskOpened::soap_default(NULL); }
	virtual ~ns1__markTaskOpened() { }
};
#endif

#ifndef SOAP_TYPE_ns1__markTaskOpenedResponse
#define SOAP_TYPE_ns1__markTaskOpenedResponse (79)
/* Primitive ns1:markTaskOpenedResponse schema type: */
class SOAP_CMAC ns1__markTaskOpenedResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__markTaskOpenedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__markTaskOpenedResponse() { ns1__markTaskOpenedResponse::soap_default(NULL); }
	virtual ~ns1__markTaskOpenedResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeProcesses
#define SOAP_TYPE_ns1__removeProcesses (80)
/* ns1:removeProcesses */
class SOAP_CMAC ns1__removeProcesses : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__processFilter *filter;	/* optional element of type ns1:processFilter */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns1__removeProcesses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeProcesses() { ns1__removeProcesses::soap_default(NULL); }
	virtual ~ns1__removeProcesses() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeProcessesResponse
#define SOAP_TYPE_ns1__removeProcessesResponse (81)
/* Primitive ns1:removeProcessesResponse schema type: */
class SOAP_CMAC ns1__removeProcessesResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__removeProcessesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeProcessesResponse() { ns1__removeProcessesResponse::soap_default(NULL); }
	virtual ~ns1__removeProcessesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSystemLogs
#define SOAP_TYPE_ns1__getSystemLogs (82)
/* ns1:getSystemLogs */
class SOAP_CMAC ns1__getSystemLogs : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns1__getSystemLogs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSystemLogs() { ns1__getSystemLogs::soap_default(NULL); }
	virtual ~ns1__getSystemLogs() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSystemLogsResponse
#define SOAP_TYPE_ns1__getSystemLogsResponse (83)
/* ns1:getSystemLogsResponse */
class SOAP_CMAC ns1__getSystemLogsResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	class ns1__systemLog **result;	/* optional element of type ns1:systemLog */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__getSystemLogsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSystemLogsResponse() { ns1__getSystemLogsResponse::soap_default(NULL); }
	virtual ~ns1__getSystemLogsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__systemLog
#define SOAP_TYPE_ns1__systemLog (84)
/* ns1:systemLog */
class SOAP_CMAC ns1__systemLog : public xsd__anyType
{
public:
	LONG64 *actorId;	/* optional element of type xsd:long */
	time_t *createDate;	/* optional element of type xsd:dateTime */
	LONG64 *id;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns1__systemLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__systemLog() { ns1__systemLog::soap_default(NULL); }
	virtual ~ns1__systemLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSystemLogsCount
#define SOAP_TYPE_ns1__getSystemLogsCount (87)
/* ns1:getSystemLogsCount */
class SOAP_CMAC ns1__getSystemLogsCount : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns1__getSystemLogsCount */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSystemLogsCount() { ns1__getSystemLogsCount::soap_default(NULL); }
	virtual ~ns1__getSystemLogsCount() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSystemLogsCountResponse
#define SOAP_TYPE_ns1__getSystemLogsCountResponse (88)
/* ns1:getSystemLogsCountResponse */
class SOAP_CMAC ns1__getSystemLogsCountResponse : public xsd__anyType
{
public:
	int result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns1__getSystemLogsCountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSystemLogsCountResponse() { ns1__getSystemLogsCountResponse::soap_default(NULL); }
	virtual ~ns1__getSystemLogsCountResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getVariablesWS
#define SOAP_TYPE_ns1__getVariablesWS (89)
/* ns1:getVariablesWS */
class SOAP_CMAC ns1__getVariablesWS : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ns1__getVariablesWS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getVariablesWS() { ns1__getVariablesWS::soap_default(NULL); }
	virtual ~ns1__getVariablesWS() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getVariablesWSResponse
#define SOAP_TYPE_ns1__getVariablesWSResponse (90)
/* ns1:getVariablesWSResponse */
class SOAP_CMAC ns1__getVariablesWSResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	class ns1__variable **result;	/* optional element of type ns1:variable */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns1__getVariablesWSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getVariablesWSResponse() { ns1__getVariablesWSResponse::soap_default(NULL); }
	virtual ~ns1__getVariablesWSResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__variable
#define SOAP_TYPE_ns1__variable (91)
/* ns1:variable */
class SOAP_CMAC ns1__variable : public xsd__anyType
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *scriptingName;	/* optional element of type xsd:string */
	wchar_t *format;	/* optional element of type xsd:string */
	wchar_t *value;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ns1__variable */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__variable() { ns1__variable::soap_default(NULL); }
	virtual ~ns1__variable() { }
};
#endif

#ifndef SOAP_TYPE_ns1__startProcessWS
#define SOAP_TYPE_ns1__startProcessWS (92)
/* ns1:startProcessWS */
class SOAP_CMAC ns1__startProcessWS : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	wchar_t *definitionName;	/* optional element of type xsd:string */
	int __sizevariables;	/* sequence of elements <variables> */
	ns1__variable **variables;	/* optional element of type ns1:variable */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns1__startProcessWS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__startProcessWS() { ns1__startProcessWS::soap_default(NULL); }
	virtual ~ns1__startProcessWS() { }
};
#endif

#ifndef SOAP_TYPE_ns1__startProcessWSResponse
#define SOAP_TYPE_ns1__startProcessWSResponse (93)
/* ns1:startProcessWSResponse */
class SOAP_CMAC ns1__startProcessWSResponse : public xsd__anyType
{
public:
	LONG64 *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns1__startProcessWSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__startProcessWSResponse() { ns1__startProcessWSResponse::soap_default(NULL); }
	virtual ~ns1__startProcessWSResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__completeTaskWS
#define SOAP_TYPE_ns1__completeTaskWS (94)
/* ns1:completeTaskWS */
class SOAP_CMAC ns1__completeTaskWS : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
	int __sizevariables;	/* sequence of elements <variables> */
	ns1__variable **variables;	/* optional element of type ns1:variable */
	LONG64 *swimlaneActorId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns1__completeTaskWS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__completeTaskWS() { ns1__completeTaskWS::soap_default(NULL); }
	virtual ~ns1__completeTaskWS() { }
};
#endif

#ifndef SOAP_TYPE_ns1__completeTaskWSResponse
#define SOAP_TYPE_ns1__completeTaskWSResponse (95)
/* Primitive ns1:completeTaskWSResponse schema type: */
class SOAP_CMAC ns1__completeTaskWSResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns1__completeTaskWSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__completeTaskWSResponse() { ns1__completeTaskWSResponse::soap_default(NULL); }
	virtual ~ns1__completeTaskWSResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateVariablesWS
#define SOAP_TYPE_ns1__updateVariablesWS (96)
/* ns1:updateVariablesWS */
class SOAP_CMAC ns1__updateVariablesWS : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	int __sizevariables;	/* sequence of elements <variables> */
	ns1__variable **variables;	/* optional element of type ns1:variable */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns1__updateVariablesWS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateVariablesWS() { ns1__updateVariablesWS::soap_default(NULL); }
	virtual ~ns1__updateVariablesWS() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateVariablesWSResponse
#define SOAP_TYPE_ns1__updateVariablesWSResponse (97)
/* Primitive ns1:updateVariablesWSResponse schema type: */
class SOAP_CMAC ns1__updateVariablesWSResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns1__updateVariablesWSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateVariablesWSResponse() { ns1__updateVariablesWSResponse::soap_default(NULL); }
	virtual ~ns1__updateVariablesWSResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSwimlanes
#define SOAP_TYPE_ns1__getSwimlanes (98)
/* ns1:getSwimlanes */
class SOAP_CMAC ns1__getSwimlanes : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns1__getSwimlanes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSwimlanes() { ns1__getSwimlanes::soap_default(NULL); }
	virtual ~ns1__getSwimlanes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getSwimlanesResponse
#define SOAP_TYPE_ns1__getSwimlanesResponse (99)
/* ns1:getSwimlanesResponse */
class SOAP_CMAC ns1__getSwimlanesResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	class ns1__wfSwimlane **result;	/* optional element of type ns1:wfSwimlane */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns1__getSwimlanesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getSwimlanesResponse() { ns1__getSwimlanesResponse::soap_default(NULL); }
	virtual ~ns1__getSwimlanesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wfSwimlane
#define SOAP_TYPE_ns1__wfSwimlane (100)
/* ns1:wfSwimlane */
class SOAP_CMAC ns1__wfSwimlane : public xsd__anyType
{
public:
	class ns1__swimlaneDefinition *definition;	/* optional element of type ns1:swimlaneDefinition */
	ns1__wfExecutor *executor;	/* optional element of type ns1:wfExecutor */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns1__wfSwimlane */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wfSwimlane() { ns1__wfSwimlane::soap_default(NULL); }
	virtual ~ns1__wfSwimlane() { }
};
#endif

#ifndef SOAP_TYPE_ns1__graphElement
#define SOAP_TYPE_ns1__graphElement (102)
/* ns1:graphElement */
class SOAP_CMAC ns1__graphElement : public xsd__anyType
{
public:
	wchar_t *nodeId;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *description;	/* optional element of type xsd:string */
	int __sizegraphConstraints;	/* sequence of elements <graphConstraints> */
	int *graphConstraints;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns1__graphElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__graphElement() { ns1__graphElement::soap_default(NULL); }
	virtual ~ns1__graphElement() { }
};
#endif

#ifndef SOAP_TYPE_ns1__delegation
#define SOAP_TYPE_ns1__delegation (103)
/* ns1:delegation */
class SOAP_CMAC ns1__delegation : public xsd__anyType
{
public:
	wchar_t *className;	/* optional element of type xsd:string */
	wchar_t *configuration;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns1__delegation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__delegation() { ns1__delegation::soap_default(NULL); }
	virtual ~ns1__delegation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcesses
#define SOAP_TYPE_ns1__getProcesses (104)
/* ns1:getProcesses */
class SOAP_CMAC ns1__getProcesses : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns1__getProcesses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcesses() { ns1__getProcesses::soap_default(NULL); }
	virtual ~ns1__getProcesses() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessesResponse
#define SOAP_TYPE_ns1__getProcessesResponse (105)
/* ns1:getProcessesResponse */
class SOAP_CMAC ns1__getProcessesResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfProcess **result;	/* optional element of type ns1:wfProcess */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns1__getProcessesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessesResponse() { ns1__getProcessesResponse::soap_default(NULL); }
	virtual ~ns1__getProcessesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTasks
#define SOAP_TYPE_ns1__getTasks (106)
/* ns1:getTasks */
class SOAP_CMAC ns1__getTasks : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns1__getTasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTasks() { ns1__getTasks::soap_default(NULL); }
	virtual ~ns1__getTasks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTasksResponse
#define SOAP_TYPE_ns1__getTasksResponse (107)
/* ns1:getTasksResponse */
class SOAP_CMAC ns1__getTasksResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfTask **result;	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns1__getTasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTasksResponse() { ns1__getTasksResponse::soap_default(NULL); }
	virtual ~ns1__getTasksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignTask
#define SOAP_TYPE_ns1__assignTask (108)
/* ns1:assignTask */
class SOAP_CMAC ns1__assignTask : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
	ns1__wfExecutor *previousOwner;	/* optional element of type ns1:wfExecutor */
	ns1__wfExecutor *newExecutor;	/* optional element of type ns1:wfExecutor */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns1__assignTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignTask() { ns1__assignTask::soap_default(NULL); }
	virtual ~ns1__assignTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignTaskResponse
#define SOAP_TYPE_ns1__assignTaskResponse (109)
/* Primitive ns1:assignTaskResponse schema type: */
class SOAP_CMAC ns1__assignTaskResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns1__assignTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignTaskResponse() { ns1__assignTaskResponse::soap_default(NULL); }
	virtual ~ns1__assignTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__wfVariableStub
#define SOAP_TYPE_ns2__wfVariableStub (110)
/* ns2:wfVariableStub */
class SOAP_CMAC ns2__wfVariableStub : public xsd__anyType
{
public:
	ns1__variableDefinition *definition;	/* optional element of type ns1:variableDefinition */
	xsd__anyType *value;	/* optional element of type xsd:anyType */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns2__wfVariableStub */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__wfVariableStub() { ns2__wfVariableStub::soap_default(NULL); }
	virtual ~ns2__wfVariableStub() { }
};
#endif

#ifndef SOAP_TYPE_ns1__identifiableBase
#define SOAP_TYPE_ns1__identifiableBase (29)
/* Primitive ns1:identifiableBase schema type: */
class SOAP_CMAC ns1__identifiableBase : public ns1__identifiable
{
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__identifiableBase */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__identifiableBase() { ns1__identifiableBase::soap_default(NULL); }
	virtual ~ns1__identifiableBase() { }
};
#endif

#ifndef SOAP_TYPE_ns1__processDefinitionDeleteLog
#define SOAP_TYPE_ns1__processDefinitionDeleteLog (85)
/* ns1:processDefinitionDeleteLog */
class SOAP_CMAC ns1__processDefinitionDeleteLog : public ns1__systemLog
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	LONG64 *version;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__processDefinitionDeleteLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__processDefinitionDeleteLog() { ns1__processDefinitionDeleteLog::soap_default(NULL); }
	virtual ~ns1__processDefinitionDeleteLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__processDeleteLog
#define SOAP_TYPE_ns1__processDeleteLog (86)
/* ns1:processDeleteLog */
class SOAP_CMAC ns1__processDeleteLog : public ns1__systemLog
{
public:
	LONG64 *processId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns1__processDeleteLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__processDeleteLog() { ns1__processDeleteLog::soap_default(NULL); }
	virtual ~ns1__processDeleteLog() { }
};
#endif

#ifndef SOAP_TYPE_ns1__swimlaneDefinition
#define SOAP_TYPE_ns1__swimlaneDefinition (101)
/* ns1:swimlaneDefinition */
class SOAP_CMAC ns1__swimlaneDefinition : public ns1__graphElement
{
public:
	ns1__delegation *delegation;	/* optional element of type ns1:delegation */
	wchar_t *orgFunctionLabel;	/* optional element of type xsd:string */
	int __sizeflowNodeIds;	/* sequence of elements <flowNodeIds> */
	wchar_t **flowNodeIds;	/* optional element of type xsd:string */
	wchar_t *scriptingName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns1__swimlaneDefinition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__swimlaneDefinition() { ns1__swimlaneDefinition::soap_default(NULL); }
	virtual ~ns1__swimlaneDefinition() { }
};
#endif

#ifndef SOAP_TYPE_ns1__executor
#define SOAP_TYPE_ns1__executor (28)
/* ns1:executor */
class SOAP_CMAC ns1__executor : public ns1__identifiableBase
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *version;	/* optional element of type xsd:long */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *description;	/* optional element of type xsd:string */
	wchar_t *fullName;	/* optional element of type xsd:string */
	time_t *createDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__executor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__executor() { ns1__executor::soap_default(NULL); }
	virtual ~ns1__executor() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wfProcess
#define SOAP_TYPE_ns1__wfProcess (44)
/* ns1:wfProcess */
class SOAP_CMAC ns1__wfProcess : public ns1__identifiableBase
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	wchar_t *name;	/* optional element of type xsd:string */
	time_t *startDate;	/* optional element of type xsd:dateTime */
	time_t *endDate;	/* optional element of type xsd:dateTime */
	int version;	/* required element of type xsd:int */
	LONG64 *definitionId;	/* optional element of type xsd:long */
	wchar_t *hierarchyIds;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__wfProcess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wfProcess() { ns1__wfProcess::soap_default(NULL); }
	virtual ~ns1__wfProcess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__actor
#define SOAP_TYPE_ns1__actor (27)
/* ns1:actor */
class SOAP_CMAC ns1__actor : public ns1__executor
{
public:
	LONG64 *code;	/* optional element of type xsd:long */
	bool active;	/* required element of type xsd:boolean */
	wchar_t *email;	/* optional element of type xsd:string */
	wchar_t *phone;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__actor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__actor() { ns1__actor::soap_default(NULL); }
	virtual ~ns1__actor() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wfExecutor
#define SOAP_TYPE_ns1__wfExecutor (41)
/* ns1:wfExecutor */
class SOAP_CMAC ns1__wfExecutor : public ns1__executor
{
public:
	wchar_t *executorClassName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__wfExecutor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wfExecutor() { ns1__wfExecutor::soap_default(NULL); }
	virtual ~ns1__wfExecutor() { }
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByCallerPrincipal
#define SOAP_TYPE___ns1__authenticateByCallerPrincipal (160)
/* Operation wrapper: */
struct __ns1__authenticateByCallerPrincipal
{
public:
	ns1__authenticateByCallerPrincipal *ns1__authenticateByCallerPrincipal_;	/* optional element of type ns1:authenticateByCallerPrincipal */
public:
	int soap_type() const { return 160; } /* = unique id SOAP_TYPE___ns1__authenticateByCallerPrincipal */
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByKerberos
#define SOAP_TYPE___ns1__authenticateByKerberos (164)
/* Operation wrapper: */
struct __ns1__authenticateByKerberos
{
public:
	ns1__authenticateByKerberos *ns1__authenticateByKerberos_;	/* optional element of type ns1:authenticateByKerberos */
public:
	int soap_type() const { return 164; } /* = unique id SOAP_TYPE___ns1__authenticateByKerberos */
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByLoginPassword
#define SOAP_TYPE___ns1__authenticateByLoginPassword (168)
/* Operation wrapper: */
struct __ns1__authenticateByLoginPassword
{
public:
	ns1__authenticateByLoginPassword *ns1__authenticateByLoginPassword_;	/* optional element of type ns1:authenticateByLoginPassword */
public:
	int soap_type() const { return 168; } /* = unique id SOAP_TYPE___ns1__authenticateByLoginPassword */
};
#endif

#ifndef SOAP_TYPE___ns1__assignSwimlaneResponse
#define SOAP_TYPE___ns1__assignSwimlaneResponse (172)
/* Operation wrapper: */
struct __ns1__assignSwimlaneResponse
{
public:
	ns1__assignSwimlaneResponse *ns1__assignSwimlaneResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:assignSwimlaneResponse */
public:
	int soap_type() const { return 172; } /* = unique id SOAP_TYPE___ns1__assignSwimlaneResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__assignSwimlane
#define SOAP_TYPE___ns1__assignSwimlane (173)
/* Operation wrapper: */
struct __ns1__assignSwimlane
{
public:
	ns1__assignSwimlane *ns1__assignSwimlane_;	/* optional element of type ns1:assignSwimlane */
public:
	int soap_type() const { return 173; } /* = unique id SOAP_TYPE___ns1__assignSwimlane */
};
#endif

#ifndef SOAP_TYPE___ns1__assignTaskResponse
#define SOAP_TYPE___ns1__assignTaskResponse (177)
/* Operation wrapper: */
struct __ns1__assignTaskResponse
{
public:
	ns1__assignTaskResponse *ns1__assignTaskResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:assignTaskResponse */
public:
	int soap_type() const { return 177; } /* = unique id SOAP_TYPE___ns1__assignTaskResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__assignTask
#define SOAP_TYPE___ns1__assignTask (178)
/* Operation wrapper: */
struct __ns1__assignTask
{
public:
	ns1__assignTask *ns1__assignTask_;	/* optional element of type ns1:assignTask */
public:
	int soap_type() const { return 178; } /* = unique id SOAP_TYPE___ns1__assignTask */
};
#endif

#ifndef SOAP_TYPE___ns1__cancelProcessResponse
#define SOAP_TYPE___ns1__cancelProcessResponse (182)
/* Operation wrapper: */
struct __ns1__cancelProcessResponse
{
public:
	ns1__cancelProcessResponse *ns1__cancelProcessResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:cancelProcessResponse */
public:
	int soap_type() const { return 182; } /* = unique id SOAP_TYPE___ns1__cancelProcessResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__cancelProcess
#define SOAP_TYPE___ns1__cancelProcess (183)
/* Operation wrapper: */
struct __ns1__cancelProcess
{
public:
	ns1__cancelProcess *ns1__cancelProcess_;	/* optional element of type ns1:cancelProcess */
public:
	int soap_type() const { return 183; } /* = unique id SOAP_TYPE___ns1__cancelProcess */
};
#endif

#ifndef SOAP_TYPE___ns1__completeTaskWSResponse
#define SOAP_TYPE___ns1__completeTaskWSResponse (187)
/* Operation wrapper: */
struct __ns1__completeTaskWSResponse
{
public:
	ns1__completeTaskWSResponse *ns1__completeTaskWSResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:completeTaskWSResponse */
public:
	int soap_type() const { return 187; } /* = unique id SOAP_TYPE___ns1__completeTaskWSResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__completeTaskWS
#define SOAP_TYPE___ns1__completeTaskWS (188)
/* Operation wrapper: */
struct __ns1__completeTaskWS
{
public:
	ns1__completeTaskWS *ns1__completeTaskWS_;	/* optional element of type ns1:completeTaskWS */
public:
	int soap_type() const { return 188; } /* = unique id SOAP_TYPE___ns1__completeTaskWS */
};
#endif

#ifndef SOAP_TYPE___ns1__getParentProcess
#define SOAP_TYPE___ns1__getParentProcess (192)
/* Operation wrapper: */
struct __ns1__getParentProcess
{
public:
	ns1__getParentProcess *ns1__getParentProcess_;	/* optional element of type ns1:getParentProcess */
public:
	int soap_type() const { return 192; } /* = unique id SOAP_TYPE___ns1__getParentProcess */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcess
#define SOAP_TYPE___ns1__getProcess (196)
/* Operation wrapper: */
struct __ns1__getProcess
{
public:
	ns1__getProcess *ns1__getProcess_;	/* optional element of type ns1:getProcess */
public:
	int soap_type() const { return 196; } /* = unique id SOAP_TYPE___ns1__getProcess */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessDiagram
#define SOAP_TYPE___ns1__getProcessDiagram (200)
/* Operation wrapper: */
struct __ns1__getProcessDiagram
{
public:
	ns1__getProcessDiagram *ns1__getProcessDiagram_;	/* optional element of type ns1:getProcessDiagram */
public:
	int soap_type() const { return 200; } /* = unique id SOAP_TYPE___ns1__getProcessDiagram */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessDiagramElements
#define SOAP_TYPE___ns1__getProcessDiagramElements (204)
/* Operation wrapper: */
struct __ns1__getProcessDiagramElements
{
public:
	ns1__getProcessDiagramElements *ns1__getProcessDiagramElements_;	/* optional element of type ns1:getProcessDiagramElements */
public:
	int soap_type() const { return 204; } /* = unique id SOAP_TYPE___ns1__getProcessDiagramElements */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessHistoryDiagram
#define SOAP_TYPE___ns1__getProcessHistoryDiagram (208)
/* Operation wrapper: */
struct __ns1__getProcessHistoryDiagram
{
public:
	ns1__getProcessHistoryDiagram *ns1__getProcessHistoryDiagram_;	/* optional element of type ns1:getProcessHistoryDiagram */
public:
	int soap_type() const { return 208; } /* = unique id SOAP_TYPE___ns1__getProcessHistoryDiagram */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessHistoryDiagramElements
#define SOAP_TYPE___ns1__getProcessHistoryDiagramElements (212)
/* Operation wrapper: */
struct __ns1__getProcessHistoryDiagramElements
{
public:
	ns1__getProcessHistoryDiagramElements *ns1__getProcessHistoryDiagramElements_;	/* optional element of type ns1:getProcessHistoryDiagramElements */
public:
	int soap_type() const { return 212; } /* = unique id SOAP_TYPE___ns1__getProcessHistoryDiagramElements */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessLogValue
#define SOAP_TYPE___ns1__getProcessLogValue (216)
/* Operation wrapper: */
struct __ns1__getProcessLogValue
{
public:
	ns1__getProcessLogValue *ns1__getProcessLogValue_;	/* optional element of type ns1:getProcessLogValue */
public:
	int soap_type() const { return 216; } /* = unique id SOAP_TYPE___ns1__getProcessLogValue */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessLogs
#define SOAP_TYPE___ns1__getProcessLogs (220)
/* Operation wrapper: */
struct __ns1__getProcessLogs
{
public:
	ns1__getProcessLogs *ns1__getProcessLogs_;	/* optional element of type ns1:getProcessLogs */
public:
	int soap_type() const { return 220; } /* = unique id SOAP_TYPE___ns1__getProcessLogs */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessTasks
#define SOAP_TYPE___ns1__getProcessTasks (224)
/* Operation wrapper: */
struct __ns1__getProcessTasks
{
public:
	ns1__getProcessTasks *ns1__getProcessTasks_;	/* optional element of type ns1:getProcessTasks */
public:
	int soap_type() const { return 224; } /* = unique id SOAP_TYPE___ns1__getProcessTasks */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcesses
#define SOAP_TYPE___ns1__getProcesses (228)
/* Operation wrapper: */
struct __ns1__getProcesses
{
public:
	ns1__getProcesses *ns1__getProcesses_;	/* optional element of type ns1:getProcesses */
public:
	int soap_type() const { return 228; } /* = unique id SOAP_TYPE___ns1__getProcesses */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessesByFilter
#define SOAP_TYPE___ns1__getProcessesByFilter (232)
/* Operation wrapper: */
struct __ns1__getProcessesByFilter
{
public:
	ns1__getProcessesByFilter *ns1__getProcessesByFilter_;	/* optional element of type ns1:getProcessesByFilter */
public:
	int soap_type() const { return 232; } /* = unique id SOAP_TYPE___ns1__getProcessesByFilter */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessesCount
#define SOAP_TYPE___ns1__getProcessesCount (236)
/* Operation wrapper: */
struct __ns1__getProcessesCount
{
public:
	ns1__getProcessesCount *ns1__getProcessesCount_;	/* optional element of type ns1:getProcessesCount */
public:
	int soap_type() const { return 236; } /* = unique id SOAP_TYPE___ns1__getProcessesCount */
};
#endif

#ifndef SOAP_TYPE___ns1__getSubprocesses
#define SOAP_TYPE___ns1__getSubprocesses (240)
/* Operation wrapper: */
struct __ns1__getSubprocesses
{
public:
	ns1__getSubprocesses *ns1__getSubprocesses_;	/* optional element of type ns1:getSubprocesses */
public:
	int soap_type() const { return 240; } /* = unique id SOAP_TYPE___ns1__getSubprocesses */
};
#endif

#ifndef SOAP_TYPE___ns1__getSwimlanes
#define SOAP_TYPE___ns1__getSwimlanes (244)
/* Operation wrapper: */
struct __ns1__getSwimlanes
{
public:
	ns1__getSwimlanes *ns1__getSwimlanes_;	/* optional element of type ns1:getSwimlanes */
public:
	int soap_type() const { return 244; } /* = unique id SOAP_TYPE___ns1__getSwimlanes */
};
#endif

#ifndef SOAP_TYPE___ns1__getSystemLogs
#define SOAP_TYPE___ns1__getSystemLogs (248)
/* Operation wrapper: */
struct __ns1__getSystemLogs
{
public:
	ns1__getSystemLogs *ns1__getSystemLogs_;	/* optional element of type ns1:getSystemLogs */
public:
	int soap_type() const { return 248; } /* = unique id SOAP_TYPE___ns1__getSystemLogs */
};
#endif

#ifndef SOAP_TYPE___ns1__getSystemLogsCount
#define SOAP_TYPE___ns1__getSystemLogsCount (252)
/* Operation wrapper: */
struct __ns1__getSystemLogsCount
{
public:
	ns1__getSystemLogsCount *ns1__getSystemLogsCount_;	/* optional element of type ns1:getSystemLogsCount */
public:
	int soap_type() const { return 252; } /* = unique id SOAP_TYPE___ns1__getSystemLogsCount */
};
#endif

#ifndef SOAP_TYPE___ns1__getTask
#define SOAP_TYPE___ns1__getTask (256)
/* Operation wrapper: */
struct __ns1__getTask
{
public:
	ns1__getTask *ns1__getTask_;	/* optional element of type ns1:getTask */
public:
	int soap_type() const { return 256; } /* = unique id SOAP_TYPE___ns1__getTask */
};
#endif

#ifndef SOAP_TYPE___ns1__getTasks
#define SOAP_TYPE___ns1__getTasks (260)
/* Operation wrapper: */
struct __ns1__getTasks
{
public:
	ns1__getTasks *ns1__getTasks_;	/* optional element of type ns1:getTasks */
public:
	int soap_type() const { return 260; } /* = unique id SOAP_TYPE___ns1__getTasks */
};
#endif

#ifndef SOAP_TYPE___ns1__getVariable
#define SOAP_TYPE___ns1__getVariable (264)
/* Operation wrapper: */
struct __ns1__getVariable
{
public:
	ns1__getVariable *ns1__getVariable_;	/* optional element of type ns1:getVariable */
public:
	int soap_type() const { return 264; } /* = unique id SOAP_TYPE___ns1__getVariable */
};
#endif

#ifndef SOAP_TYPE___ns1__getVariablesWS
#define SOAP_TYPE___ns1__getVariablesWS (268)
/* Operation wrapper: */
struct __ns1__getVariablesWS
{
public:
	ns1__getVariablesWS *ns1__getVariablesWS_;	/* optional element of type ns1:getVariablesWS */
public:
	int soap_type() const { return 268; } /* = unique id SOAP_TYPE___ns1__getVariablesWS */
};
#endif

#ifndef SOAP_TYPE___ns1__markTaskOpenedResponse
#define SOAP_TYPE___ns1__markTaskOpenedResponse (272)
/* Operation wrapper: */
struct __ns1__markTaskOpenedResponse
{
public:
	ns1__markTaskOpenedResponse *ns1__markTaskOpenedResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:markTaskOpenedResponse */
public:
	int soap_type() const { return 272; } /* = unique id SOAP_TYPE___ns1__markTaskOpenedResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__markTaskOpened
#define SOAP_TYPE___ns1__markTaskOpened (273)
/* Operation wrapper: */
struct __ns1__markTaskOpened
{
public:
	ns1__markTaskOpened *ns1__markTaskOpened_;	/* optional element of type ns1:markTaskOpened */
public:
	int soap_type() const { return 273; } /* = unique id SOAP_TYPE___ns1__markTaskOpened */
};
#endif

#ifndef SOAP_TYPE___ns1__removeProcessesResponse
#define SOAP_TYPE___ns1__removeProcessesResponse (277)
/* Operation wrapper: */
struct __ns1__removeProcessesResponse
{
public:
	ns1__removeProcessesResponse *ns1__removeProcessesResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:removeProcessesResponse */
public:
	int soap_type() const { return 277; } /* = unique id SOAP_TYPE___ns1__removeProcessesResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__removeProcesses
#define SOAP_TYPE___ns1__removeProcesses (278)
/* Operation wrapper: */
struct __ns1__removeProcesses
{
public:
	ns1__removeProcesses *ns1__removeProcesses_;	/* optional element of type ns1:removeProcesses */
public:
	int soap_type() const { return 278; } /* = unique id SOAP_TYPE___ns1__removeProcesses */
};
#endif

#ifndef SOAP_TYPE___ns1__startProcessWS
#define SOAP_TYPE___ns1__startProcessWS (282)
/* Operation wrapper: */
struct __ns1__startProcessWS
{
public:
	ns1__startProcessWS *ns1__startProcessWS_;	/* optional element of type ns1:startProcessWS */
public:
	int soap_type() const { return 282; } /* = unique id SOAP_TYPE___ns1__startProcessWS */
};
#endif

#ifndef SOAP_TYPE___ns1__updateVariablesWSResponse
#define SOAP_TYPE___ns1__updateVariablesWSResponse (286)
/* Operation wrapper: */
struct __ns1__updateVariablesWSResponse
{
public:
	ns1__updateVariablesWSResponse *ns1__updateVariablesWSResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:updateVariablesWSResponse */
public:
	int soap_type() const { return 286; } /* = unique id SOAP_TYPE___ns1__updateVariablesWSResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__updateVariablesWS
#define SOAP_TYPE___ns1__updateVariablesWS (287)
/* Operation wrapper: */
struct __ns1__updateVariablesWS
{
public:
	ns1__updateVariablesWS *ns1__updateVariablesWS_;	/* optional element of type ns1:updateVariablesWS */
public:
	int soap_type() const { return 287; } /* = unique id SOAP_TYPE___ns1__updateVariablesWS */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (288)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 288; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (289)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 289; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (291)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 291; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (294)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 294; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (295)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 295; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
